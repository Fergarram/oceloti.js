<!DOCTYPE html>
<html oceloti-reset="black">
<head>
	<meta charset="utf-8">
	<title>Arena Garden</title>
	<meta name="description" content="A simple room arena cards.">
	<link rel="icon" href="../assets/icon.png"></link>
	<style oceloti-modules="
		css-reset
		oceloti
		inventory
		paper-theme
	">/* MODULE: modules/css-reset/css-reset.css */
*, *::before, *::after {
  padding: 0;
  margin: 0;
  box-sizing: border-box;
}

img, picture, video, canvas, svg {
  display: block;
  max-width: 100%;
}

input, button, textarea, select {
  font: inherit;
}

p, h1, h2, h3, h4, h5, h6 {
  overflow-wrap: break-word;
}

fieldset {
  border: none;
  outline: none;
}

/* MODULE: modules/oceloti/oceloti.css */
[oceloti-reset] {
	scroll-behavior: smooth;
}

[oceloti-reset="black"] {
	background-color: black;
}

[oceloti-reset] body {
	display: flex;
	align-items: center;
	justify-content: center;
	min-height: 100vh;
	min-width: 100vw;
	width: fit-content;
	margin: 0;
	padding: 0;
}

[oceloti-room] {
	position: relative;
	overflow: hidden;
}

[oceloti-card] {
	position: absolute;
}

[oceloti-area] {
	position: absolute;
	width: 100vw;
	height: 100vh;
	transform: translate(-50%, -50%);
	opacity: 0;
	pointer-events: none;
}

[oceloti-area][debug] {
	background-color: salmon;
	opacity: 0.5;
}

[oceloti-area="center"] {
	left: 50%;
	top: 50%;
	display: block;
	transform: translate(-50%, -50%);
}

/* MODULE: modules/inventory/inventory.css */

/* MODULE: modules/paper-theme/paper-theme.css */
:root {
	--card-thickness-1:
		drop-shadow(0 0 1px rgba(0, 0, 0, 0.5))
		drop-shadow(0 1px 2px rgba(0, 0, 0, 0.23));
	--card-thickness-2:
		drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5))
		drop-shadow(0 1px 3px rgba(0, 0, 0, 0.23));
	--card-thickness-3:
		drop-shadow(0 2px 2px rgba(0, 0, 0, 0.5))
		drop-shadow(0 1px 4px rgba(0, 0, 0, 0.23));
	--card-elevated-1:
		drop-shadow(0 1.25rem 3rem rgba(0, 0, 0, 0.30))
		drop-shadow(0 1rem 2rem rgba(0, 0, 0, 0.22));
	--card-elevated-2:
		drop-shadow(0 1.25rem 1.5rem rgba(0, 0, 0, 0.30))
		drop-shadow(0 1rem 1rem rgba(0, 0, 0, 0.22));
	--ease-curve-1:
		cubic-bezier(0.16, 1, 0.3, 1);
}

html {
	font-size: 14px;
	font-family: monospace;
}

.paper {
	filter: var(--card-thickness-1);
}

.backpack:hover {
	transform: scale(1.1);
}

[oceloti-card] {
	transition: filter, transform var(--ease-curve-1) 300ms;
}

[oceloti-card-state="elevated"] {
	transform: scale(1.015);
	filter: var(--card-elevated-1);
	cursor: move;
}

[oceloti-dialog] {
	border: none;
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	padding: 1rem;
	border-radius: 0.5rem;
}

[oceloti-dialog]::backdrop {
	background-color: rgba(0, 0, 0, 0.25);
}

.nugget {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.35rem;
	border-radius: 0.5rem;
	background-color: lavender;
}

.nugget > p {
	display: flex;
	padding: 0 0.5rem;
}

.nugget-error {
	background-color: lightsalmon;
	color: black;
}

.nugget-success {
	background-color: darkseagreen;
	color: black;
}

button {
	display: flex;
	align-items: center;
	gap: 3px;
	line-height: 1.2;
	background: lightgray;
	color: black;
	padding: 0.15rem 0.5rem;
	border-radius: 0.5rem;
	border: none;
	cursor: pointer;
	text-transform: lowercase;
	transition: filter, transform var(--ease-curve-1) 150ms;
	filter: drop-shadow(2px 2px);
}

button:hover {
	background-color: lightblue;
}

button:active {
	background-color: skyblue;
	transform: scale(0.95);
	filter: drop-shadow(0px 0px);
}

button.selected {
	background-color: mediumaquamarine;
}

#hud {
	position: fixed;
	left: 0;
	top: 0;
	display: flex;
	flex-wrap: wrap;
	gap: 8px;
	padding: 12px;
}

.inventory-grid {
	display: grid;
	grid-template-columns: repeat(4, 1fr);
	gap: 2px;
	padding: 4px;
	position: absolute;
	left: 0;
	bottom: -8px;
	width: fit-content;
	max-height: 65vh;
	overflow: scroll;
	background-color: lightgray;
	border-radius: 0.5rem;
	transform: translateY(100%);
	filter: drop-shadow(2px 2px);
}

.inventory-slot {
	border: 1px solid darkgray;
	border-radius: 4px;
	width: 48px;
	height: 48px;
}
</style>
</head>
<body>
	<main
		oceloti-room="basic-starter"
		style="
			width: 2000px;
			height: 2000px;
			background-color: white;
/*			background-image: url('../assets/wood.png');*/
			background-image: url('../assets/grid2.png');
			background-size: 128px;
			image-rendering: pixelated;
	">
		<div id="center" aria-hidden="true" oceloti-area="center"></div>

		<article
			oceloti-card=""
			class="paper"
			style="
				left: 400px;
				top: 240px;
				width: 300px;
				height: 400px;
				overflow: scroll;
				padding: 8px;
				background-color: #f9f7ee;
			">
			<div style="
				width: 100%;
				height: 100%;
				background-image: url('../assets/grid1.png');
				background-size: 20px;
				line-height: 20px;
				padding: 0 4px;
				image-rendering: pixelated;
			">
				In any case...<br />
				In any case...<br />
				In any case...<br />
				In any case...<br />
				In any case...<br />
				In any case...<br />
			</div>
		</article>

		<figure id="clock" oceloti-card="" style="
			position: relative;
			overflow: hidden;
			border-radius: 500px;
			left: 800px;
			top: 20px;
			width: 200px;
			height: 200px;
		">
			<img
				draggable="false"
				style="
					max-width: unset;
					position: absolute;
					left: 50%;
					top: 50%;
					transform: translate(-50%, -50%) scale(0.5);
				"
				src="https://d2w9rnfcy7mm78.cloudfront.net/93462/original_45ef418ca39caeea179b55d058de97c3.gif?1364910097?bc=1"
				alt="clock">
		</figure>
	</main>
	<div id="hud"></div>
</body>
<script oceloti-modules="
	oceloti
	standard-controls
	draggable-cards
	van
	arena-api
	inventory
	arena-cards
	image-dropper
	save-to-file
">/* MODULE: modules/standard-controls/standard-controls.js */
(async () => {
	const room_el = document.querySelector("[oceloti-room]");

	let room_width = 0;
	let room_height = 0;

	if (room_el) {
		room_width = room_el.offsetWidth;
		room_height = room_el.offsetHeight;
	}

	// @TODO: Save zoom to local storage.
	window.zoom = 100;

	const last_scroll_x = localStorage.getItem("OCELOTI_SCROLL_X");
	const last_scroll_y = localStorage.getItem("OCELOTI_SCROLL_Y");

	let camera_x = last_scroll_x !== null ? last_scroll_x : 0;
	let camera_y = last_scroll_y !== null ? last_scroll_y : 0;

	let last_middle_click_x = 0;
	let last_middle_click_y = 0;

	let is_panning = false;
	let scroll_ticking = false;

	window.requestAnimationFrame(step);
	window.addEventListener("mousedown", handle_mousedown);
	window.addEventListener("mouseup", handle_mouseup);
	window.addEventListener("mousemove", handle_mousemove);
	window.addEventListener("scroll", handle_scroll);
	window.addEventListener("wheel", handle_wheel, { passive: false });

	function step(dt) {
		if (camera_x <= 0) camera_x = 0;
		if (camera_y <= 0) camera_y = 0;
		if (camera_x >= room_width - window.innerWidth) camera_x = room_width - window.innerWidth;
		if (camera_y >= room_height - window.innerHeight) camera_y = room_height - window.innerHeight;
		if (is_panning) {
			window.scroll({
				top: camera_y,
				left: camera_x,
				behavior: "instant"
			});
		}
		window.requestAnimationFrame(step);
	}

	function are_dialogs_open() {
		const dialogs = document.querySelectorAll('dialog');
		return Array.from(dialogs).some(dialog => dialog.open);
	}

	function handle_mousedown(e) {
		if (are_dialogs_open()) {
			e.preventDefault();
			return;
		}
		if (e.button === 1) {
			e.preventDefault();
			is_panning = true;
			last_middle_click_x = e.clientX;
			last_middle_click_y = e.clientY;
		}
	}

	function handle_mouseup(e) {
		if (e.button === 1) {
			is_panning = false;
		}
	}

	function handle_mousemove(e) {
		if (is_panning) {
			const dx = e.clientX - last_middle_click_x;
			const dy = e.clientY - last_middle_click_y;
			camera_x -= dx;
			camera_y -= dy;
			last_middle_click_x = e.clientX;
			last_middle_click_y = e.clientY;
		}
	}

	function handle_scroll(e) {
		if (!scroll_ticking) {
			window.requestAnimationFrame(() => {
				camera_x = window.scrollX;
				camera_y = window.scrollY;
				localStorage.setItem("OCELOTI_SCROLL_X", camera_x);
				localStorage.setItem("OCELOTI_SCROLL_Y", camera_y);
				scroll_ticking = false;
			});
			scroll_ticking = true;
		}
	}

	function handle_wheel(e) {
		if (are_dialogs_open()) {
			e.preventDefault();
			return;
		}

		if (!e.ctrlKey) return;

		const dir = e.deltaY > 0 ? -10 : 10;
		let zoom = window.devicePixelRatio * 100;
		zoom = Math.round(zoom + dir);
		zoom = Math.round(zoom / 10) * 10;
		window.zoom = zoom;
		window.dispatchEvent(new Event("zoom"));
	}
})();
/* MODULE: modules/draggable-cards/draggable-cards.js */
(async () => {
	const card_query = document.querySelectorAll("[oceloti-card]");
	const room = document.querySelector("[oceloti-room]");

	if (!card_query || !room) return;

	const all_cards = Array.from(card_query);

	let last_mouse_x = 0;
	let last_mouse_y = 0;
	let delta_x = 0;
	let delta_y = 0;
	let dragged_card = null;
	let dragging_x = 0;
	let dragging_y = 0;

	const observer = new MutationObserver((mutations) => {
		for (let mutation of mutations) {
			if (mutation.type === "childList") {
				if (mutation.addedNodes.length > 0) {
					mutation.addedNodes.forEach((node) => {
						if (
							node.id !== "oceloti-floating-card" &&
							node.getAttribute("oceloti-card-state") !== "elevated" &&
							node.hasAttribute("oceloti-card")
						) {
							initialize_card(node);
						}
					});
				}

				// if (mutation.removedNodes.length > 0) {
				// 	mutation.removedNodes.forEach((node) => {
				// 		console.log(node);
				// 	});
				// }
			}
		}
	});

	observer.observe(room, { childList: true });

	all_cards.forEach(initialize_card);

	function initialize_card(card) {
	    setTimeout(() => {
	    	card.setAttribute("oceloti-card-state", "idle");
		    card.style.removeProperty("will-change");
		    card.style.removeProperty("pointer-events");
	    }, 0);

		card.addEventListener("mousedown", handle_mousedown);

		function handle_mousedown(e) {
		    if (!e.target) return;
		    if (dragged_card !== null) return;
		    const target = e.target;
		    if (
		        typeof target.dataset.ignoredrag !== "undefined" ||
		        target.dataset.ignoredrag === "true" ||
		        target.dataset.ignoredrag === true ||
		        target.tagName === "A" ||
		        target.tagName === "BUTTON" ||
		        target.tagName === "INPUT" ||
		        target.tagName === "TEXTAREA" ||
		        (
		        	target.tagName === "IMG" && 
		        	target.getAttribute("draggable") !== "false"
		        ) 
		    ) {
		        return;
		    }

		    if (e.button !== 0) return;

		    let x = Number(card.style.left.replace("px", ""));
	    	let y = Number(card.style.top.replace("px", ""));
	    	dragging_x = x;
	    	dragging_y = y;

		    last_mouse_x = e.clientX;
		    last_mouse_y = e.clientY;

		    card.style.willChange = "filter, transform";
		    card.style.pointerEvents = "none";
		    const card_html = card.outerHTML;
		    card.remove();

		    const floating_wrapper = document.createElement("div");

		    floating_wrapper.id = "oceloti-floating-card";
		    floating_wrapper.style.pointerEvents = "none";
		    floating_wrapper.style.position = "absolute";
		    floating_wrapper.style.left = "0";
		    floating_wrapper.style.top = "0";
		    floating_wrapper.style.willChange = "transform";
		    floating_wrapper.style.transform = `translate(${x}px, ${y}px)`;
		    floating_wrapper.innerHTML = card_html;

		    const inner_card = floating_wrapper.firstElementChild;
		    inner_card.style.left = "";
		    inner_card.style.top = "";

		    room.appendChild(floating_wrapper);
		    dragged_card = inner_card;

		    window.addEventListener("mousemove", handle_mousemove);
		    window.addEventListener("mouseup", handle_mouseup);
		}
	}

	function handle_mousemove(e) {
	    if (e.button !== 0) return;

	    delta_x = last_mouse_x - e.clientX;
	    delta_y = last_mouse_y - e.clientY;
	    last_mouse_x = e.clientX;
	    last_mouse_y = e.clientY;

	    if (dragged_card) {
	    	dragged_card.setAttribute("oceloti-card-state", "elevated");
	    	dragging_x = dragging_x - delta_x;
	    	dragging_y = dragging_y - delta_y;
	    	dragged_card.parentElement.style.transform = `translate(${dragging_x}px, ${dragging_y}px)`;
	    }
	}

	function handle_mouseup(e) {
	    if (e.button !== 0) return;
	    const wrapper = dragged_card.parentNode;
	    wrapper.after(dragged_card);

	    dragged_card.style.left = `${dragging_x}px`;
	    dragged_card.style.top = `${dragging_y}px`;
	    initialize_card(dragged_card);

	    wrapper.remove();
	    dragged_card = null;

	    window.removeEventListener("mousemove", handle_mousemove);
	    window.removeEventListener("mouseup", handle_mouseup);
	}
})();
/* MODULE: modules/van/van.js */
(() => {
  // van.js
  var Obj = Object;
  var _undefined;
  var protoOf = Obj.getPrototypeOf;
  var doc = document;
  var changedStates;
  var curDeps;
  var curNewDerives;
  var alwaysConnectedDom = { isConnected: 1 };
  var gcCycleInMs = 1e3;
  var statesToGc;
  var propSetterCache = {};
  var objProto = protoOf(alwaysConnectedDom);
  var funcProto = protoOf(protoOf);
  var addAndScheduleOnFirst = (set, s, f, waitMs) => (set ?? (setTimeout(f, waitMs), /* @__PURE__ */ new Set())).add(s);
  var runAndCaptureDeps = (f, deps, arg) => {
    let prevDeps = curDeps;
    curDeps = deps;
    try {
      return f(arg);
    } catch (e) {
      console.error(e);
      return arg;
    } finally {
      curDeps = prevDeps;
    }
  };
  var keepConnected = (l) => l.filter((b) => b._dom?.isConnected);
  var addStatesToGc = (d) => statesToGc = addAndScheduleOnFirst(statesToGc, d, () => {
    for (let s of statesToGc)
      s._bindings = keepConnected(s._bindings), s._listeners = keepConnected(s._listeners);
    statesToGc = _undefined;
  }, gcCycleInMs);
  var stateProto = {
    get val() {
      curDeps?._getters?.add(this);
      return this._val;
    },
    get oldVal() {
      curDeps?._getters?.add(this);
      return this._oldVal;
    },
    set val(v) {
      curDeps?._setters?.add(this);
      if (v !== this._val) {
        this._val = v;
        let listeners = [...this._listeners = keepConnected(this._listeners)];
        for (let l of listeners)
          derive(l.f, l.s, l._dom), l._dom = _undefined;
        this._bindings.length ? changedStates = addAndScheduleOnFirst(changedStates, this, updateDoms) : this._oldVal = v;
      }
    }
  };
  var state = (initVal) => ({
    __proto__: stateProto,
    _val: initVal,
    _oldVal: initVal,
    _bindings: [],
    _listeners: []
  });
  var isState = (s) => protoOf(s ?? 0) === stateProto;
  var val = (s) => isState(s) ? s.val : s;
  var oldVal = (s) => isState(s) ? s.oldVal : s;
  var bind = (f, dom) => {
    let deps = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, binding = { f }, prevNewDerives = curNewDerives;
    curNewDerives = [];
    let newDom = runAndCaptureDeps(f, deps, dom);
    newDom = (newDom ?? doc).nodeType ? newDom : new Text(newDom);
    for (let d of deps._getters)
      deps._setters.has(d) || (addStatesToGc(d), d._bindings.push(binding));
    for (let l of curNewDerives)
      l._dom = newDom;
    curNewDerives = prevNewDerives;
    return binding._dom = newDom;
  };
  var derive = (f, s = state(), dom) => {
    let deps = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, listener = { f, s };
    listener._dom = dom ?? curNewDerives?.push(listener) ?? alwaysConnectedDom;
    s.val = runAndCaptureDeps(f, deps, s._val);
    for (let d of deps._getters)
      deps._setters.has(d) || (addStatesToGc(d), d._listeners.push(listener));
    return s;
  };
  var add = (dom, ...children) => {
    for (let c of children.flat(Infinity)) {
      let protoOfC = protoOf(c ?? 0);
      let child = protoOfC === stateProto ? bind(() => c.val) : protoOfC === funcProto ? bind(c) : c;
      child != _undefined && dom.append(child);
    }
    return dom;
  };
  var _ = (f) => (f._isBindingFunc = 1, f);
  var tagsNS = (ns) => new Proxy((name, ...args) => {
    let [props, ...children] = protoOf(args[0] ?? 0) === objProto ? args : [{}, ...args];
    let dom = ns ? doc.createElementNS(ns, name) : doc.createElement(name);
    for (let [k, v] of Obj.entries(props)) {
      let getPropDescriptor = (proto) => proto ? Obj.getOwnPropertyDescriptor(proto, k) ?? getPropDescriptor(protoOf(proto)) : _undefined;
      let cacheKey = name + "," + k;
      let propSetter = propSetterCache[cacheKey] ?? (propSetterCache[cacheKey] = getPropDescriptor(protoOf(dom))?.set ?? 0);
      let setter = k.startsWith("on") ? (v2, oldV) => {
        let event = k.slice(2);
        dom.removeEventListener(event, oldV);
        dom.addEventListener(event, v2);
      } : propSetter ? propSetter.bind(dom) : dom.setAttribute.bind(dom, k);
      let protoOfV = protoOf(v ?? 0);
      protoOfV === funcProto && (!k.startsWith("on") || v._isBindingFunc) && (v = derive(v), protoOfV = stateProto);
      protoOfV === stateProto ? bind(() => (setter(v.val, v._oldVal), dom)) : setter(v);
    }
    return add(dom, ...children);
  }, { get: (tag, name) => tag.bind(_undefined, name) });
  var update = (dom, newDom) => newDom ? newDom !== dom && dom.replaceWith(newDom) : dom.remove();
  var updateDoms = () => {
    let changedStatesArray = [...changedStates].filter((s) => s._val !== s._oldVal);
    changedStates = _undefined;
    for (let b of new Set(changedStatesArray.flatMap((s) => s._bindings = keepConnected(s._bindings))))
      update(b._dom, bind(b.f, b._dom)), b._dom = _undefined;
    for (let s of changedStatesArray)
      s._oldVal = s._val;
  };
  var hydrate = (dom, f) => update(dom, bind(f, dom));
  var van_default = { add, _, tags: tagsNS(), tagsNS, state, val, oldVal, derive, hydrate };

  // van.forbundle.js
  window.van = van_default;
})();
/* MODULE: modules/arena-api/arena-api.js */
async function arena_sign_in(token) {
	if (!token) {
		console.error("Can't sign in without token.");
		return {
			status: "error",
			message: "Can't sign in without token."
		};
	}

	try {
		const user = await fetch_arena({
			endpoint: "/me",
			token
		});
		localStorage.setItem("ARENA_TOKEN", token);
		return {
			status: "success",
			message: `Hello ${user.full_name}.`,
			user
		}
	} catch(e) {
		console.error("Failed to sign in with token:", token);
		return {
			status: "error",
			message: "Bad token. Use a different token or generate again."
		};
	}
}

async function fetch_arena({
	endpoint,
	token,
	params = "",
	body = {}
}) {
	const local_token = localStorage.getItem("ARENA_TOKEN");

	const BASE_URL = 'https://api.are.na/v2';

	const headers = { "Content-Type": "application/json" }

	if (token || local_token) {
		headers["Authorization"] = `Bearer ${token || local_token}`
	}

	const response = await fetch(`${BASE_URL}${endpoint}${params}`, {
		method: "GET",
		headers
	});

	if (!response.ok)
		throw new Error('Network response was not ok');

	return response.json();
}
/* MODULE: modules/inventory/inventory.js */
(async () => {
	if (!van) {
		console.error("The inventory module depends on van.js");
		return;
	};

	const hud = document.getElementById("hud");
	const room = document.querySelector("[oceloti-room]");
	
	if (!room || !hud) return;

	const { div, button, img } = van.tags;

	const slots = [
		1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
		1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
	];

	const inventory_launcher = div({
		style: "position: relative;",
	},
		button({
			onclick: (e) => {
				e.target.classList.toggle("selected");
			}
		},
			img({
				src: "../assets/icons/backpack.svg",
				alt: ""
			}),
			"backpack"
		),
		div({
			class: "inventory-grid"
		},
			slots.map(slot => div({ class: "inventory-slot" }))
		)
	);

	van.add(hud, inventory_launcher);

})();
/* MODULE: modules/arena-cards/arena-cards.js */
(async () => {
	if (!van) {
		console.error("The inventory module depends on van.js");
		return;
	};

	const hud = document.getElementById("hud");
	const room = document.querySelector("[oceloti-room]");
	
	if (!room || !hud) return;

	const { dialog, form, fieldset, input, p, div, a, button } = van.tags;

	const dialog_el = dialog({
		"oceloti-dialog": "arena-token",
		onclose: (e) => e.target.remove(),
		style: `
			display: flex;
			flex-direction: column;
			gap: 1rem;
		`,
	},
		form({
			method: "dialog",
			onsubmit: async (e) => {
				e.preventDefault();
				const form = new FormData(e.target);
				const fields = {};
				for (const [key, value] of form.entries()) {
					fields[key] = value;
				}
				
				const res = await arena_sign_in(fields.token);

				const messages_el = dialog_el.querySelector("[oceloti-dialog-messages]");

				messages_el.innerHTML = "";
				
				if (res.status === "error") {
					van.add(messages_el, div({
						"class": "nugget nugget-error"
					}, 
						p(res.message)
					));
					return;
				}

				if (res.status === "success") {
					van.add(messages_el, div({ 
						"class": "nugget nugget-success"
					},
						p(res.message),
						button({ onclick: () => dialog_el.close()}, 
							"Close"
						)
					));
				}
			}
		},
			p({
				style: "margin-bottom: 1rem;",
			},
				"Sign In to use Are.na blocks."
			),
			fieldset({
				style: `
					display: flex;
					gap: 0.5rem;
				`
			},
				input({
					"name": "token",
					"type": "text",
					"required": "true",
					"style": "width: 100%;",
					"autocomplete": "off",
					// @TODO: Fix this absurd bug... wtf.
					onclick: (e) => e.target.focus()
				}),
				button({
					style: `
						width: fit-content;
						white-space: nowrap;
					`,
					"type": "submit"
				},
					"add token"
				)
			)
		),
		div({
			"oceloti-dialog-messages": ""
		},
			div({
				class: "nugget"
			},
				p(
					"To get your token visit: ",
					a({
						style: "margin-left: 8px;",
						target: "_blank",
						href: "https://arena-token-gen.vercel.app/"
					},
						"suna.garden/get-token"
					)
				),
			)
		)
	);

	van.add(hud, button({
		onclick: () => {
			van.add(document.body, dialog_el);
			dialog_el.showModal();
		}
	},
		"** are.na cards"
	));
})();
/* MODULE: modules/image-dropper/image-dropper.js */
(async () => {
	const room = document.querySelector("[oceloti-room]");
	if (!room) return;

	room.addEventListener("dragover", (e) => {
		e.stopPropagation();
		e.preventDefault();
		e.dataTransfer.dropEffect = "copy";
	});

	room.addEventListener("drop", (drop_event) => {
		drop_event.stopPropagation();
		drop_event.preventDefault();
		const files = drop_event.dataTransfer.files;

		if (files.length) {
			const file = files[0];
			if (file.type.startsWith("image/")) {
				const reader = new FileReader();
				reader.onload = (e) => {
					const img = new Image();
					img.onload = () => {
						const image_card = document.createElement("figure");
						image_card.setAttribute("oceloti-card", "");
						image_card.classList.add("paper");
						image_card.style.left = `${window.scrollX + drop_event.clientX - (img.naturalWidth / 2)}px`;
						image_card.style.top = `${window.scrollY + drop_event.clientY - (img.naturalHeight / 2)}px`;
						image_card.style.width = `${img.naturalWidth}px`;
						image_card.style.height = `${img.naturalHeight}px`;
						image_card.appendChild(img);
						room.appendChild(image_card);
					};
					img.src = e.target.result;
					img.setAttribute("draggable", "false");
				};
				reader.readAsDataURL(file);
			}
		}
	});
})();

/* MODULE: modules/save-to-file/save-to-file.js */
(async () => {
	if (!van) {
		console.error("The inventory module depends on van.js");
		return;
	};

	const { dialog, p, div, a } = van.tags;

	window.addEventListener("keydown", handle_keydown);

	function handle_keydown(e) {
		if ((e.metaKey || e.ctrlKey) && e.key === "s") {
			e.preventDefault();

			const dom_content = "<!DOCTYPE html>\n" + document.documentElement.outerHTML;

			const dialog_el = dialog({
				"oceloti-dialog": "save-to-file",
				onclose: (e) => e.target.remove()
			},
				div({
					style: `
						display: flex;
						align-items: center;
						justify-content: center;
						flex-direction: column;
						gap: 0.75rem;
					`
				},
					p(`Right-click download link to "save as".`),
					a("Download")
				)
			);

			van.add(document.body, dialog_el)
			
			setTimeout(() => {
				const blob = new Blob([dom_content], { type: 'text/html' });
				const url = URL.createObjectURL(blob);
				const dialog_el = document.querySelector(`[oceloti-dialog="save-to-file"]`);
				const link_el = dialog_el.querySelector("a");
				link_el.href = url;
				link_el.download = `${document.title}.html`;
				
				dialog_el.showModal();
			}, 0);
		}
	}
})();
</script>
</html>